## PHP对象注入漏洞(PHP反序列化漏洞)

### 漏洞说明

反序列化为序列化的逆过程，将字符串恢复成对象，PHP中使用unserialize函数完成反序列化的操作  

PHP的 unserialize() 函数只能反序列化在当前程序上下文中已经被定义过的类.  
在传统的PHP中你需要通过使用一大串的include() 或者 require()来包含所需的类定义文件。  
autoloading 技术,他可以自动导入需要使用的类  
Composer php的包管理工具,能自动导入所有依赖库中定义的类，所以unserialize()函数就能使用所有依赖库中的类了  


反序列化对象允许控制所有属性： **public、protected以及private**  

在反序列化中,我们所能控制的数据就是对象中的各个属性值,所以在PHP的反序列化有一种漏洞利用方法叫做 "面向属性编程" ,即 POP( Property Oriented Programming)。

生成序列化字符串的时候记得urlencode一下，因为如果类中存在protected或private属性，在序列化时会有一些空字节，直接输出是看不出来的，payload也不会生效。




__construct()	// 当对象创建(new实例化)时会自动调用,在unserialize()时是不会自动调用的  
__wakeup()		// 使用unserialize时触发  
__sleep()		// 使用serialize时触发  
__destruct()	// 对象被销毁时触发  
__call()		// 在对象上下文中调用不可访问的方法时触发  
__callStatic()	// 在静态上下文中调用不可访问的方法时触发  
__get()			// 用于从不可访问的属性读取数据  
__set()			// 用于将数据写入不可访问的属性  
__isset()		// 在不可访问的属性上调用isset()或empty()触发  
__unset()		// 在不可访问的属性上使用unset()时触发  
__toString()	// 把类当作字符串使用时触发  
__invoke()		// 当脚本尝试将对象调用为函数时触发  




### 漏洞修复 
使用unserialize进行反序列化时，禁止传入对象类型。  
使用json_encode/json_decode代替serialize/unserialize。


### 参考：
[http://www.freebuf.com/vuls/80293.html](http://www.freebuf.com/vuls/80293.html)  
[https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/](https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/)  
[https://www.anquanke.com/post/id/84922](https://www.anquanke.com/post/id/84922)  
[http://lynahex.com/index.php/archives/PHP-Object-Injection.html](http://lynahex.com/index.php/archives/PHP-Object-Injection.html)  
[http://programmer.zhujunwu.cn/article/26859](http://programmer.zhujunwu.cn/article/26859)  
[http://foreversong.cn/archives/772](http://foreversong.cn/archives/772)  
[http://seaii-blog.com/index.php/2017/09/12/70.html](http://seaii-blog.com/index.php/2017/09/12/70.html)  
Practical PHP Object Injection.pdf
